```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(rusboost)
library(pROC)
# How to rename them by using for loop?
# Importance of dealing with serial fraud in fraud prediction models.
# The value of model6 is too strange (too many predicted fraud) and used time is little
# Error: cannot allocate vector of size 1.3 GB
# Year 7 and 8 have the worst result
```

Adjust threshold values and note down sensitivity and 1-specificity
Write 1-2 paragraphs summarize the result

```{r Creating data}
split_train_test <- function (year, data) {
  train <<- data %>%
    filter(fyear <= year - 2)
  test <<- data %>%
    filter(fyear == year)
}

split_train_test(2003, data)
train_3 <- train
test_3 <- test
split_train_test(2004, data)
train_4 <- train
test_4 <- test
split_train_test(2005, data)
train_5 <- train
test_5 <- test
split_train_test(2006, data)
train_6 <- train
test_6 <- test
split_train_test(2007, data)
train_7 <- train
test_7 <- test
split_train_test(2008, data)
train_8 <- train
test_8 <- test
```

```{r}
year3_time_100 #13 mins
time_200 #30 mins
time_500 #1 hour
time_1500 #2 hours
time_3000 #5 hours
year3_time_5000 #8 hours
year4_time_3000 #4 hours
year5_time_3000 #4 hours
year6_time_3000 #45 mins???
year7_time_3000 #8 hours??? 
year8_time_3000 #8 hours???
```

```{r}
train_3 %>% 
  count(misstate == 1)
train_4 %>% 
  count(misstate == 1)
train_5 %>% 
  count(misstate == 1)
train_6 %>% 
  count(misstate == 1)
train_7 %>% 
  count(misstate == 1)
train_8 %>% 
  count(misstate == 1)
test_8 %>% 
  count(misstate == 1)
```

```{r Second NDCG Function}
DCG <- function (k, ranking){
  DCG <- 0
  for (i in 1:k){
  DCG = DCG +(2^(ranking[i]) - 1)/(log2(i + 1))
  }
  return(DCG)
}

NDCG2 <- function (k, Relevance, Predicted) {
  DCGk <- DCG(k, Predicted)
  iDCGk <- DCG(k, Relevance)
#  cat("DCG of the predicted order is", DCGk, "\nDCG of the ideal order(iDCG) is", iDCGk, "\n")
  return(DCGk/iDCGk)
}
```

```{r}
yearly_test_set <- list(test_3,test_4,test_5,test_6, test_7, test_8)
yearly_preds <- list(year3_preds_3000,year4_preds_3000,year5_preds_3000,year6_preds_3000,year7_preds_3000,year8_preds_3000)

yearly_sensitivity <- NULL
yearly_precision <- NULL
yearly_auc <- NULL
yearly_NDCG <- NULL

for (i in 1:6) {
  print(yearly_preds[[i]]$confusion)
  
  roc_obj <- roc(predictor = yearly_preds[[i]]$prob[,2], 
               response = yearly_test_set[[i]]$misstate)
  yearly_auc[i] = auc(roc_obj)
  plot(roc_obj, legacy.axes = TRUE)

  yearly_sensitivity[i] <-
    yearly_preds[[i]]$confusion[2,2]/sum(yearly_preds[[i]]$confusion[,2])
  yearly_precision[i] <- yearly_preds[[i]]$confusion[2,2]/sum(yearly_preds[[i]]$confusion[2,])

  k <- floor(0.01*nrow(yearly_test_set[[i]]))
  RelevanceLevel <- as.numeric(as.character(sort(yearly_test_set[[i]]$misstate, decreasing = TRUE)))
  testpred <- cbind(yearly_test_set[[i]], data.frame(yearly_preds[[i]]$prob[,1]))
  names(testpred)[52] <- "preds"
  testpred <- testpred %>% arrange(preds)
  PredictedRank <- as.numeric(as.character(testpred$misstate))
  yearly_NDCG[i] <- NDCG2(k, Relevance = RelevanceLevel, Predicted = PredictedRank)
}

mean(yearly_auc)
mean(yearly_precision)
mean(yearly_sensitivity)
mean(yearly_NDCG)
# Why predicted is reversed? What is Vote and Probability?
```

```{r}
roc_obj <- roc(predictor = yearly_preds[[5]]$prob[,2], 
               response = yearly_test_set[[5]]$misstate)
plot(roc_obj, legacy.axes = TRUE)


roc_obj <- roc(predictor = yearly_preds[[6]]$prob[,2], 
               response = yearly_test_set[[6]]$misstate)
plot(roc_obj, legacy.axes = TRUE)
```
```{r}
hist(year8_preds_3000$votes[,1])
```


Paper:
AUC = 0.725 
NDCG = 0.049 
Sensitivity = 4.88%
Precision = 4.48%

